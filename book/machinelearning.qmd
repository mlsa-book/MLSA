---
abstract: TODO (150-200 WORDS)
---

{{< include _setup.qmd >}}

# Machine Learning {#sec-ml}

{{< include _wip_minor.qmd >}}

This chapter covers core concepts in machine learning.
This is not intended as a comprehensive introduction and does not cover mathematical theory nor how to run machine learning models using software.
Instead, the focus is on introducing important concepts and to provide basic intuition for a general machine learning workflow. This includes the concept of a machine learning task, data splitting (resampling), model training and prediction, evaluation, and model comparison.
@Hastie2013 provide a very good introduction to machine learning, with more detail in @Hastie2001.
There are several books covering machine learning implementations in various programming languages, for example @Bischl2024 and @Kuhn2023 for $\Rstats$ and @Geron2019 for Python.

## Basic workflow {#sec-ml-basics}

This book focuses on *supervised learning*, in which predictions are made for outcomes based on data with observed dependent and independent variables.
For example, predicting someone's height is a supervised learning problem as data can be collected for features (independent variables) such as age and sex, and an observable outcome (dependent variable), which is height.
Alternatives to supervised learning include *unsupervised learning*, *semi-supervised learning*, and *reinforcement learning*.
This book is primarily concerned with *predictive* survival analysis, i.e., making future predictions based on (partially) observed survival outcomes, which falls naturally within the supervised learning domain.

The basic machine learning workflow is represented in @fig-ml-basic.
Data is split into training and test datasets.
A learner is selected and is trained on the training data, becoming a fitted model.
The features from the test data are passed to the model which makes predictions for the unseen labels.
The labels from the test data are passed to a chosen measure with the predictions, which evaluates the performance of the model.
The process of repeating this procedure to test different training and test data is called *resampling* and running multiple resampling experiments with different models is called *benchmarking*.
All these concepts will be explained in this chapter.

![Basic machine learning workflow with data splitting, model training, predicting, and evaluating. Image from @Foss2024 (CC BY-NC-SA 4.0).](https://mlr3book.mlr-org.com/chapters/chapter2/Figures/mlr3book_figures-1.svg){#fig-ml-basic}

<!-- FIXME - TO USE IN PRINT WE NEED PERMISSION FROM ALL AUTHORS OR NEED TO MAKE OUR OWN VERSION -->

## Tasks {#sec-ml-tasks}

A machine learning task is the specification of the mathematical problem that is to be solved by a given algorithm.
For example, "predict the height of a male, 13 year old child", is a machine learning task.
Tasks are derived from datasets and one dataset will give rise to many tasks across any machine learning domain.
The dataset described by columns: 'age', 'weight', 'height', 'sex', 'diagnosis', 'time of death', 'clinician notes', could give rise to any of the following tasks:

* Predict age from all other features - supervised regression
* Predict sex from a subset of features - supervised classification
* Predict time of death from all other features - supervised survival
* Categorise observations into clusters - unsupervised clustering
* Learn to speak like a clinician depending on client diagnosis - natural language processing, likely with reinforcement learning

As this book is focused only on supervised learning, only the first three of these is covered in this chapter and beyond.
The specification of a task is vital for interpreting predictions from a model and its subsequent performance.
Say three models are using the above features to predict 'sex', which of the following are comparable?

* M1: Feature selection followed by training. During feature selection, only 'age', 'weight', and 'height' are kept;
* M2: No feature selection. Trained on all features.
* M3: No feature selection. Trained on 'age', 'weight', 'height'.

Only M1 and M2 can be fairly compared as these are solving the same task: given all features predict 'sex'.
In contrast M3 solves the task: given only 'age', 'weight' and 'height', predict 'sex'.
This subtle difference is important for evaluating model performance and in a medical context can remove potential biases.
For example, for M1 one might conclude "given all available data, XYZ", whereas with M3 data has been deliberately omitted.

Formally, let $\xx \in \calX \subseteq \Reals^{n \times p}$ be a matrix with $p$ features for $n$ observations and let $y \in \calY$ be a vector of labels (or *outcomes* or *targets*) for all observations.
A dataset is then given by $\calD = ((\xx_1, y_1) , . . . , (\xx_n, y_n))$ where it is assumed $\calD \iid (\mathbb{P}_{xy})^n$ for some unknown distribution $\mathbb{P}$.

A machine learning task is the problem of learning the unknown function: $f : \calX \rightarrow \calY$ where $\calY$ specifies the nature of the task, for example classification, regression, or survival.

### Regression {#sec-ml-tasks-regr}

Regression tasks make continuous predictions, for example someone's height.
Regression may be deterministic, in which case a single continuous value is predicted, or probabilistic, where a probability distribution over the Reals is predicted.
For example, predicting an individual's height as 165cm would be a deterministic regression prediction, whereas predicting their height follows a $\calN(165, 2)$ distribution would be probabilistic.

Formally, a deterministic regression task is specified by $f_{Rd} : \calX \rightarrow \calY \subseteq \Reals^n$, and a probabilistic regression task by $f_{Rp} : \calX \rightarrow \calS$ where $\calS \subset \Distr(\calY)$.

Deterministic regression is much more common than probabilistic and hence the shorthand 'regression' is used to refer to deterministic regression unless otherwise stated.

### Classification {#sec-ml-tasks-classif}

Classification tasks make discrete predictions, for example whether it will rain, snow, or be sunny tomorrow.
Similarly to regression, predictions may be deterministic or probabilistic.
Deterministic classification predicts which category an observation falls into, whereas probabilistic classification predicts the probability of an observation falling into each category.
Predicting it will rain tomorrow is a deterministic prediction whereas predicting $\hatp(rain) = 0.6; \hatp(snow) = 0.1; \hatp(sunny) = 0.3$ is probabilistic.

Formally, a deterministic classification task is given by $f_{Cd} : \calX \rightarrow \calY \subseteq \Naturals$, and a probabilistic classification task as $f_{Cp} : \calX \rightarrow \calY \subseteq [0,1]^k$ where $k$ is the number of categories an observation may fall into.
Practically this latter prediction is estimation of the probability mass function $\hat{p}_Y(y) = P(Y = y)$.
If only two categories are possible, these reduce to the *binary classification* tasks: $f_{Bd}: \calX \rightarrow \{0, 1\}$ and $f_{Bp}: \calX \rightarrow [0, 1]$ for deterministic and probabilistic binary classification respectively.

Note that in the probabilistic binary case it is common to write the task as predicting $[0,1]$ not $[0,1]^2$ as the classes are mutually exclusive.
The class for which probabilities are predicted is referred to as the *positive class*, and the other as the *negative class*.

## Training and predicting {#sec-ml-models}

The terms *algorithm*, *learner*, and *model* are often conflated in machine learning.
A *learning algorithm*, *algorithm*, or *learner*, is a strategy to estimate the unknown mapping from features to outcome as represented by a task, $f: \calX \rightarrow \calY$.
Given a learner, $LA$, and data, $\calD$, then $\hat{f} := LA(\calD | \theta, \Theta)$.
The terms $\theta$ and $\Theta$ represent model parameters and hyperparameters that are used to fit and control the algorithm respectively.
Model *parameters* (or *weights*) are coefficients to be estimated during model training, these are not directly controlled by a user (i.e., the person training the model) but are instead solely determined by the data and influenced by hyperparameters.
Model *hyperparameters* control *how* the algorithm is run, for example determining if the intercept should be included in a linear regression model (@cnj-lm).
The number of hyperparameters usually increases with learner complexity and performance, and often hyperparameters need to be tuned (@sec-ml-opt) instead of manually set.

The process of passing data, $\calD$, setting hyperparameters, $\Theta$, to a learner is known as *training* and the learner is *trained* by estimating the parameters, $\theta$, this trained learner is called a *model*.
Computationally, storing $(\hat{\theta}, \Theta)$ is sufficient to recreate any trained model (assuming the learner is known), and sharing of model weights is common for deep learning models.

Once trained, a model can be used for predictions.
As well as encoding a specific learning strategy, learners also define a prediction strategy.
For traditional statistical models this strategy might be a simple calculation based on the trained coefficients (e.g., predicting a linear predictor @sec-surv-set-types), or for more complex machine learning models this could be an iterative algorithmic procedure with multiple steps.
Given a trained model, $\hat{f}$, and some new features $\xx^* \in \Reals^p$, the model's prediction for the unseen label is $\haty := \hat{f}(\xx^* | \theta, \Theta)$ or more simply $\hatyy := \hatf(\xx^*)$.
Note that there can also be hyperparameters specific to the prediction step.

:::: {.callout-note icon=false}

## Linear regression

::: {#cnj-lm}
Let $f_R : \calX \rightarrow \calY$ be the regression task of interest with $\calX \subseteq \Reals^n$ and $\calY \subseteq \Reals^n$.
Let $(\xx, \yy)$ be data such that $\xx \in \calX$ and $\yy \in \calY$.

Say the learner of interest is a linear regression model with learning algorithm:

$$
(\hat{\beta_0}, \hat{\beta_1}) := \argmin_{\beta_0,\beta_1} \Big\{\sum^n_{i=1} (y_i - \gamma\beta_0 - \beta_1 x_i)^2\Big\}\text{ for }i = 1,...,n
$$

and prediction algorithm:

$$
\hatg(x) = \gamma\hat{\beta_0} + \hat{\beta_1}x
$$

The learner hyperparameters are $\Theta = (\gamma)$ which can take values $0$ or $1$ and the parameters are $\theta = (\beta_0, \beta_1)$.
The learner is fit by passing $(\xx, \yy)$ to the learning algorithm and thus estimating $\hat{\theta}$ and $\hatg$.
A prediction, $\haty$, is made for a new observation by passing $x^* \in \calX$ to the fitted model $\hatg$.

:::

::::

## Evaluating and benchmarking {#sec-ml-eval}

To understand if a model is 'good', its predictions are evaluated with a *loss function*.
Loss functions assign a score to the discrepancy between predictions and true values, $L: \calY \times \calY \rightarrow \ExtReals$.
Given real-world data, $(\XX^*, \yy^*)$, and a trained model $\hatf$, then the loss is given by $L(\hatf{\XX^*}, \yy^*) = L(\hatyy, \yy^*)$.
For a model to be useful, it should perform well in general, and not just for the data used for training and development, which is known as a model's *generalization error*.

A model should not be deployed, i.e., manually or automatically used to make predictions, its generalization error must be estimated to understand if the model is 'good'.
If a model were to be trained and evaluated on the same data, the resulting loss, known as the *training error*, would be an overoptimistic estimate of the true generalization error (@Hastie2013) as the model is making predictions for data it has already 'seen' and the loss is not evaluating its ability to generalize to new, unseen data.
Estimation of the generalization error requires *data splitting*, which is the process of splitting available data, $\calD$, into *training data*, $\dtrain \subset \calD$, and *testing data*, $\dtest = \calD \setminus \dtrain$.
<!-- FIXME: ABOVE COULD BE BETTER WORDED -->

The simplest method to estimate the generalization error is to use *holdout resampling*, which is the process of partitioning the data into one training dataset and one testing dataset, with the model trained on the former and predictions made for the latter.
Using 2/3 of the data for training and 1/3 for testing is a common splitting ratio (@Kohavi1995).
When splitting, it is essential the data is partitioned randomly to ensure any information encoded in data ordering is removed.
Ordering is often important in the real-world, for example in healthcare data when patients are recorded in order of enrolment to a study.
Whilst ordering can provide useful information, it does not generalize to new, unseen data.
For example, the number of days a patient has been in hospital is more useful than the patient's index in the dataset, as the former could be calculated for a new patient whereas the latter is meaningless.
Another example is in the `rats` dataset that was briefly described in @sec-surv.
The `rats` data explores how a novel drug effects tumor incidence.
However, the data is ordered by rat litters with every three rats being in the same litter.
Hence if rats were to be bred or raised differently over time,  even if the `litter` column were removed, this information would still be encoded in the order of the dataset and could impact upon any findings.
Randomly splitting breaks any possible association between order and outcome.
<!-- FIXME: ABOVE IS ALSO BAD! -->

Holdout resampling is a quick method to estimate the generalization error, however it is an imperfect method as, even with random splitting, it can still result in 'unlucky' splits.
Returning to the `rats` data, consider a split that results in only male rats in the training data, the model would then be unable to handle female rats in the testing data, which it had never encountered before.
Alternatively, consider a random split with an even sex balance, as only two out of the 150 rats have a tumor, there is a high probability that the training data will not include any male rat with a tumor.
Hence, in the case of a male rat, the model is likely to ignore the treatment variable and instead just use sex as the most important predictor of tumor incidence.

To deal with this problem, $k$-fold cross-validation (CV) can be used as a more robust method and to better estimate the generalization error [@Hastie2001].
$k$-fold CV partitions the data into $k$ subsets, called *folds*.
The training data comprises of $k-1$ of the folds and the remaining one is used for testing and evaluation.
This is repeated $k$ times until each of the folds has been used exactly once as the testing data.
The performance from each fold is averaged into a final performance estimate.
It is common to use $k = 5$ or $k = 10$ [@Breiman1992; @Kohavi1995].
This process can be repeated multiple times (*repeated $k$-fold CV*) and/or $k$ can even be set to $n$, which is known as *leave-one-out cross-validation*.

Cross-validation can also be stratified, which ensures that a variable of interest will have the same distribution in each fold as in the original data.
This is important, and often recommended, in survival analysis to ensure that the proportion of censoring in each fold is representative of the full dataset.
<!-- FIXME: CITE OUR SURVIVAL BENCHMARK PAPER -->

Repeating resampling experiments with multiple models is referred to as a *benchmark experiment*.
A benchmark experiment compares models by evaluating their performance on *identical* data, which means the same resampling strategy and folds should be used for all models.
Determining if one model is actually better than another is a surprisingly complex topic [@Demsar2006; @Dietterich1998; @Nadeau2003] and is out of scope for this book, instead any benchmark experiments performed in this book are purely for illustrative reasons and no results are expected to generalize outside of these experiments.

## Optimization {#sec-ml-opt}

@sec-ml-models introduced model hyperparameters, which control how training and prediction algorithms are run.
Setting hyperparameters is a critical part of model fitting and can significantly change model performance.
*Tuning* is the process of using internal benchmark experiment to automatically select the optimal hyper-parameter configuration.
For example, the number of trees, $m_r$ in a random forest (@sec-surv-ml-models-ranfor) is a potential hyperparameter to tune.
This hyperparameter may be tuned over a range of values, say $[10, 1000]$ or over a discrete subset, say $\{10, 100, 1000\}$, for now assume the latter.
Three random forests with $10$, $100$, and $1000$ trees respectively are compared in a benchmark experiment.
The number of trees that results in the model with the optimal performance is then selected for the hyperparameter value going forward.
*Nested resampling* is a common method to prevent overfitting that could occur from using overlapping data for tuning, training, or testing.
Nested resampling is the process of resampling the training set again for tuning and then the optimal model is refit on the entire training data (@fig-ml-nested).

![An illustration of nested resampling. The large blocks represent three-fold CV for the outer resampling for model evaluation and the small blocks represent four-fold CV for the inner resampling for HPO. The light blue blocks are the training sets and the dark blue blocks are the test sets. Image and caption from @Becker2024 (CC BY-NC-SA 4.0).](https://mlr3book.mlr-org.com/chapters/chapter4/Figures/mlr3book_figures-11.svg){#fig-ml-nested}

## Conclusion

:::: {.callout-warning icon=false}

## Key takeaways

* Machine learning tasks define the predictive problem of interest;
* Regression tasks make continuous predictions and classification tasks make discrete predictions;
* Models have parameters that are fit during training and hyperparameters that are set or tuned;
* Models should be resampled to estimate the generalization error to understand future performance.

::::

:::: {.callout-tip icon=false}

## Further reading

* @Hastie2001 and @Hastie2013 for comprehensive introductions and overviews to machine learning.
* @Bischl2012 for discussion about more resampling strategies including bootstrapping and subsampling.

::::
