---
abstract: TODO (150-200 WORDS)
---
::: {.content-hidden}
$$
%-----------------------
% packages
%-----------------------
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{thmtools}
\usepackage{bm}
\usepackage{algpseudocode,algorithm,algorithmicx}
\usepackage{xspace}

\providecommand{\eop}{\hfill$\qed$}
\renewcommand{\vec}[1]{\mathbf{#1}}

\providecommand{\cb}{\mathbf{c}}
\providecommand{\mb}{\mathbf{m}}
\providecommand{\nb}{\mathbf{n}}
\providecommand{\Frac}{\operatorname{Frac}}
\providecommand{\Stab}{\operatorname{Stab}}
\providecommand{\Spec}{\operatorname{Spec}}
\providecommand{\Supp}{\operatorname{Supp}}
\providecommand{\supp}{\operatorname{supp}}
\providecommand{\cosupp}{\operatorname{cosupp}}
\providecommand{\vsupp}{\operatorname{vsupp}}
\providecommand{\Ker}{\operatorname{Ker}}
\providecommand{\Gr}{\operatorname{Gr}}
\providecommand{\codim}{\operatorname{codim}}
\providecommand{\rk}{\operatorname{rk}}
\providecommand{\argmin}{\operatornamewithlimits{argmin}}
\providecommand{\argmax}{\operatornamewithlimits{argmax}}
\providecommand{\lcm}{\operatorname{lcm}}
\providecommand{\trdeg}{\operatorname{trdeg}}
\providecommand{\codeg}{\operatorname{codeg}}
\providecommand{\id}{\operatorname{id}}
\providecommand{\Tr}{\operatorname{Tr}}
\providecommand{\res}{\operatorname{res}}
\providecommand{\rank}{\operatorname{rank}}
\providecommand{\chr}{\operatorname{char}}
\providecommand{\sgn}{\operatorname{sgn}}
\providecommand{\mesh}{\operatorname{mesh}}
\providecommand{\Corr}{\operatorname{Corr}}
\providecommand{\Cov}{\operatorname{Var}}
\providecommand{\Var}{\operatorname{Var}}
\providecommand{\Bias}{\operatorname{Bias}}
\providecommand{\logit}{\operatorname{logit}}
\providecommand{\odds}{\operatorname{odds}}

\providecommand{\iid}{\stackrel{i.i.d.}\sim}
\providecommand{\otherw}{\text{otherwise}}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\providecommand{\mean}[2][n]{\frac{1}{#1} \sum^{#1}_{i = 1} #2}

\providecommand{\distrT}{\ensuremath{\Distr(\calT)}}
\providecommand{\distrY}{\Distr(\calY)}
\providecommand{\distrPR}{\Distr(\PReals)}
\providecommand{\proba}{\pkg{mlr3proba}}
\providecommand{\distrix}{\pkg{distr6}}
\providecommand{\setsix}{\pkg{set6}}
\providecommand{\rsix}{\pkg{R62S3}}
\providecommand{\paramsix}{\pkg{param6}}
\providecommand{\dtrain}{\calD_{train}}
\providecommand{\dtest}{\calD_{test}}
\providecommand{\CDetI}{(C1)\xspace}
\providecommand{\CDetII}{(C2)\xspace}
\providecommand{\CProb}{(C3)\xspace}
\providecommand{\CAvg}{(C4)\xspace}
\providecommand{\CSR}{(C5)\xspace}
\providecommand{\KMS}{\hatS_{KM}\xspace}
\providecommand{\KMG}{\hatG_{KM}\xspace}
%-----------------------
% Capital Greek letters
%-----------------------
\providecommand{\Alpha}{\mathrm{A}}
\providecommand{\Beta}{\mathrm{B}}
\providecommand{\Epsilon}{\mathrm{E}}
\providecommand{\Tau}{\mathrm{T}}

%-----------------------
% calligraphic letters
%-----------------------
\providecommand{\calA}{\mathcal{A}}
\providecommand{\calB}{\mathcal{B}}
\providecommand{\calC}{\mathcal{C}}
\providecommand{\calD}{\mathcal{D}}
\providecommand{\calE}{\mathcal{E}}
\providecommand{\calF}{\mathcal{F}}
\providecommand{\calG}{\mathcal{G}}
\providecommand{\calH}{\mathcal{H}}
\providecommand{\calI}{\mathcal{I}}
\providecommand{\calJ}{\mathcal{J}}
\providecommand{\calK}{\mathcal{K}}
\providecommand{\calL}{\mathcal{L}}
\providecommand{\calM}{\mathcal{M}}
\providecommand{\calN}{\mathcal{N}}
\providecommand{\calO}{\mathcal{O}}
\providecommand{\calP}{\mathcal{P}}
\providecommand{\calQ}{\mathcal{Q}}
\providecommand{\calR}{\mathcal{R}}
\providecommand{\calS}{\mathcal{S}}
\providecommand{\calT}{\mathcal{T}}
\providecommand{\calU}{\mathcal{U}}
\providecommand{\calV}{\mathcal{V}}
\providecommand{\calW}{\mathcal{W}}
\providecommand{\calX}{\mathcal{X}}
\providecommand{\calY}{\mathcal{Y}}
\providecommand{\calZ}{\mathcal{Z}}

%-----------------------
% hat letters
%-----------------------
\providecommand{\hata}{\hat{a}}
\providecommand{\hatb}{\hat{b}}
\providecommand{\hatc}{\hat{c}}
\providecommand{\hatd}{\hat{d}}
\providecommand{\hate}{\hat{e}}
\providecommand{\hatf}{\hat{f}}
\providecommand{\hatg}{\hat{g}}
\providecommand{\hath}{\hat{h}}
\providecommand{\hati}{\hat{i}}
\providecommand{\hatj}{\hat{j}}
\providecommand{\hatk}{\hat{k}}
\providecommand{\hatl}{\hat{l}}
\providecommand{\hatm}{\hat{m}}
\providecommand{\hatn}{\hat{n}}
\providecommand{\hato}{\hat{o}}
\providecommand{\hatp}{\hat{p}}
\providecommand{\hatq}{\hat{q}}
\providecommand{\hatr}{\hat{r}}
\providecommand{\hats}{\hat{s}}
\providecommand{\hatt}{\hat{t}}
\providecommand{\hatu}{\hat{u}}
\providecommand{\hatv}{\hat{v}}
\providecommand{\hatw}{\hat{w}}
\providecommand{\hatx}{\hat{x}}
\providecommand{\haty}{\hat{y}}
\providecommand{\hatz}{\hat{z}}

\providecommand{\hatA}{\hat{A}}
\providecommand{\hatB}{\hat{B}}
\providecommand{\hatC}{\hat{C}}
\providecommand{\hatD}{\hat{D}}
\providecommand{\hatE}{\hat{E}}
\providecommand{\hatF}{\hat{F}}
\providecommand{\hatG}{\hat{G}}
\providecommand{\hatH}{\hat{H}}
\providecommand{\hatI}{\hat{I}}
\providecommand{\hatJ}{\hat{J}}
\providecommand{\hatK}{\hat{K}}
\providecommand{\hatL}{\hat{L}}
\providecommand{\hatM}{\hat{M}}
\providecommand{\hatN}{\hat{N}}
\providecommand{\hatO}{\hat{O}}
\providecommand{\hatP}{\hat{P}}
\providecommand{\hatQ}{\hat{Q}}
\providecommand{\hatR}{\hat{R}}
\providecommand{\hatS}{\hat{S}}
\providecommand{\hatT}{\hat{T}}
\providecommand{\hatU}{\hat{U}}
\providecommand{\hatV}{\hat{V}}
\providecommand{\hatW}{\hat{W}}
\providecommand{\hatX}{\hat{X}}
\providecommand{\hatY}{\hat{Y}}
\providecommand{\hatZ}{\hat{Z}}

%-----------------------
% fracture letters
%-----------------------
\providecommand{\frakA}{\mathfrak{A}}
\providecommand{\frakI}{\mathfrak{I}}
\providecommand{\frakJ}{\mathfrak{J}}
\providecommand{\frakP}{\mathfrak{P}}
\providecommand{\frakQ}{\mathfrak{Q}}
\providecommand{\frakS}{\mathfrak{S}}
\providecommand{\frakY}{\mathfrak{Y}}

\providecommand{\fraks}{\mathfrak{s}}

%-----------------------
% double lined letters
%-----------------------
\providecommand{\ZZ}{\mathbb{Z}}
\providecommand{\RR}{\mathbb{R}}
\providecommand{\PP}{\mathbb{P}}
\providecommand{\QQ}{\mathbb{Q}}
\providecommand{\FF}{\mathbb{F}}
\providecommand{\CC}{\mathbb{C}}
\providecommand{\NN}{\mathbb{N}}
\providecommand{\KK}{\mathbb{K}}
\providecommand{\EE}{\mathbb{E}}
\providecommand{\II}{\mathbb{I}}
\providecommand{\xx}{\mathbf{x}}
\providecommand{\yy}{\mathbf{y}}

%-----------------------
% number sets
%-----------------------
\providecommand*{\Naturals}{\mathbb{N}_0}
\providecommand*{\PNaturals}{\mathbb{N}_{> 0}}

\providecommand*{\Integers}{\mathbb{Z}}
\providecommand*{\PIntegers}{\mathbb{Z}_{>0}}
\providecommand*{\NNIntegers}{\mathbb{Z}_{\geq 0}}
\providecommand*{\NIntegers}{\mathbb{Z}_{< 0}}
\providecommand*{\NPIntegers}{\mathbb{Z}_{\leq 0}}

\providecommand*{\Rationals}{\mathbb{Q}}
\providecommand*{\PRationals}{\mathbb{Q}_{>0}}
\providecommand*{\NNRationals}{\mathbb{Q}_{\geq 0}}
\providecommand*{\NRationals}{\mathbb{Q}_{< 0}}
\providecommand*{\NPRationals}{\mathbb{Q}_{\leq 0}}

\providecommand*{\Reals}{\mathbb{R}}
\providecommand*{\PReals}{\mathbb{R}_{>0}}
\providecommand*{\NNReals}{\mathbb{R}_{\geq 0}}
\providecommand*{\NReals}{\mathbb{R}_{< 0}}
\providecommand*{\NPReals}{\mathbb{R}_{\leq 0}}

\providecommand*{\ExtReals}{\bar{\mathbb{R}}}
\providecommand*{\Complex}{\mathbb{C}}

\providecommand{\bset}{\{0,1\}}


%-----------------------
% bold letters
%-----------------------
\providecommand{\bfi}{\mathbf{i}}
\providecommand{\bft}{\mathbf{t}}

\providecommand{\ba}{\boldsymbol{a}}
\providecommand{\bb}{\boldsymbol{b}}
\providecommand{\bo}{\boldsymbol{o}}
\providecommand{\bi}{\boldsymbol{i}}
\providecommand{\bj}{\boldsymbol{j}}
\providecommand{\bp}{\boldsymbol{p}}
\providecommand{\br}{\boldsymbol{r}}
\providecommand{\bs}{\boldsymbol{s}}
\providecommand{\bt}{\boldsymbol{t}}
\providecommand{\bu}{\boldsymbol{u}}
\providecommand{\bw}{\boldsymbol{w}}
\providecommand{\bx}{\boldsymbol{x}}
\providecommand{\by}{\boldsymbol{y}}

\providecommand{\balpha}{\boldsymbol{\alpha}}
\providecommand{\bbeta}{\boldsymbol{\beta}}
\providecommand{\bgamma}{\boldsymbol{\gamma}}
\providecommand{\blambda}{\boldsymbol{\lambda}}
\providecommand{\bsigma}{\boldsymbol{\sigma}}
\providecommand{\btau}{\boldsymbol{\tau}}

\providecommand{\bL}{\boldsymbol{L}}
\providecommand{\bN}{\boldsymbol{N}}
\providecommand{\bP}{\boldsymbol{P}}
\providecommand{\bW}{\boldsymbol{W}}
\providecommand{\bX}{\boldsymbol{X}}
\providecommand{\bY}{\boldsymbol{Y}}

%-----------------------
% distributions
%-----------------------
\providecommand{\Distr}{\operatorname{Distr}}
\providecommand{\Bern}{\operatorname{Bern}}
\providecommand{\Binom}{\operatorname{Binom}}
\providecommand{\Exp}{\operatorname{Exp}}
\providecommand{\Gomp}{\operatorname{Gompertz}}
\providecommand{\Hyper}{\operatorname{Hyper}}
\providecommand{\Llogis}{\operatorname{Loglogistic}}
\providecommand{\Lnorm}{\operatorname{Lognormal}}
\providecommand{\Weib}{\operatorname{Weibull}}

\providecommand{\indep}{\perp \!\!\! \perp}
\providecommand{\pkg}[1]{\textbf{#1}\xspace}
\providecommand{\Rstats}{\textsf{R}\xspace}
\providecommand{\etal}{\textit{et al.}\xspace}


$$
:::

```{r utils,echo=FALSE}
toproper = function(str) {
  str = strsplit(str, " ", TRUE)[[1]]
  paste0(toupper(substr(str, 1, 1)), tolower(substr(str, 2, 100)), collapse = " ")
}
```

```{r index_functions, include = FALSE, cache = FALSE}
index = function(main = NULL, code = FALSE, lower = TRUE) {
  entry = if (code || !lower) main else tolower(main)
  text = if (code) sprintf("`%s`", main) else main
  sprintf("\\index{%s}%s", entry, main)
}
```

```{r link_functions, include = FALSE, cache = FALSE}
link = function(url) {
  sprintf("[%s](%s)", url, url)
}
```

```{r reference_functions, include = FALSE, cache = FALSE}
ref = function(topic, index = FALSE) {

  topic = trimws(topic)

  stopifnot(grepl(pattern = "^[[:alnum:]]::[[:alnum:]]$"), topic)

  if (grepl("::", topic, fixed = TRUE)) {
    parts = strsplit(topic, "::", fixed = TRUE)[[1L]]
    topic = parts[2L]
    name = sub("\\(\\)$", "", parts[2L])
    pkg = parts[1L]
  }

  url = sprintf("https://www.rdocumentation.org/packages/%s/topics/%s", pkg, name)

  out = sprintf("[`%s`](%s)", topic, url)

  if (index) {
    out = paste0(out, index(main = NULL, index = topic, code = TRUE))
  }

  out
}
```

```{r reference_packages, include = FALSE, cache = FALSE}
pkg = function(pkg, github = TRUE, index = TRUE) {
  pkg = trimws(pkg)

  if (grepl("/", pkg, fixed = TRUE)) {
    if (github) {
      out = .gh_pkg(pkg)
    } else {
      out = .ru_pkg(pkg)
    }
  } else {
    out = .cran_pkg(pkg)
  }

  if (index) {
    out = sprintf("%s\\index{\\texttt{%s}}", out, pkg)
  }

  out
}

.cran_pkg = function(pkg) {
  if (pkg %in% c("stats", "graphics", "datasets")) {
    sprintf("`%s`", pkg)
  } else {
    url = sprintf("https://cran.r-project.org/package=%s", pkg)
    sprintf("[`%s`](%s)", pkg, url)
  }
}

.gh_pkg = function(pkg) {
  sprintf("[`%s`](https://github.com/%s)", pkg, pkg)
}

.ru_pkg = function(pkg) {
  parts = strsplit(pkg, "/", fixed = TRUE)[[1L]]
  url = sprintf("https://%s.r-universe.dev/ui#package:%s", parts[1L], parts[2L])
  sprintf("[`%s`](%s)", pkg, url)
}
```

```{r include_multi_graphics, include = FALSE, cache = FALSE}
include_multi_graphics = function(fig_name) {
  fmt = if (knitr::is_latex_output()) "png" else "svg"
  knitr::include_graphics(sprintf("Figures/%s.%s", fig_name, fmt), dpi = 600)
}
```

```{r sign, include = FALSE, cache = FALSE, results="asis"}
sign <- function(ref, msg_fmt = "See @%s for useful context.",
  ttl_fmt = "Get more context") {
  cat(
    ":::{.callout-tip icon=false}",
    sprintf("## 🪧 %s", ttl_fmt),
    sprintf(msg_fmt, ref),
    ":::",
    sep = "\n"
  )
}

learn <- function(ref, about, msg_fmt = "See @%s to learn more about %s.",
  ttl_fmt = "Learn more about %s") {
  cat(
    ":::{.callout-tip icon=false}",
    sprintf("## 🪧 %s", sprintf(ttl_fmt, about)),
    sprintf(msg_fmt, ref, about),
    ":::",
    sep = "\n"
  )
}
```



# Calibration Measures {#sec-eval-distr-calib}

::: {.callout-important}
## Page in progress!

**This page is a work in progress and will change significantly over time.**
:::



Calibration measures evaluate the 'average' quality of survival distribution predictions.
This chapter is kept relatively short as the literature in this area is scarce [@Rahman2017], this is likely due to the meaning of calibration being unclear in a survival context [@VanHouwelingen2000].
However the meaning of calibration is better specified once specific metrics are introduced.
As with other measure classes, only measures that can generalise beyond Cox PH models are included here but note that several calibration measures for re-calibrating PH models have been discussed in the literature [@Demler2015; @VanHouwelingen2000].

Calibration measures can be grouped [@Andres2018] into those that evaluate distributions at a single time-point, '1-Calibration' or 'Point Calibration' measures, and those that evaluate distributions at all time-points 'distributional-calibration' or 'probabilistic calibration' measures.
A point-calibration measure will evaluate a function of the predicted distribution at a single time-point whereas a probabilistic measure evaluates the distribution over a range of time-points; in both cases the evaluated quantity is compared to the observed outcome, $(T, \Delta)$.

## Point Calibration {#sec-eval-distr-calib-point}

Point calibration measures can be further divided into metrics that evaluate calibration at a single time-point (by reduction) and measures that evaluate an entire distribution by only considering the event time.
The difference may sound subtle but it affects conclusions that can be drawn.
In the first case, a calibration measure can only draw conclusions at that one time-point, whereas the second case can draw conclusions about the calibration of the entire distribution.
This is the same caveat as using prediction error curves for scoring rules.


```{r echo=FALSE}
learn("sec-pecs", "prediction error curves")
```


### Calibration by Reduction

Point calibration measures are implicitly reduction methods as they use classification methods to evaluate a full distribution based on a single point only.
For example, given a predicted survival function $\hatS$, one could calculate the survival function at a single time point, $\hatS{\tau}$ and then use probabilistic classification calibration measures.
Using this approach one may employ common calibration methods such as the Hosmer–Lemeshow test [@Hosmer1980].
Measuring calibration in this way can have significant drawbacks as a model may be well-calibrated at one time-point but poorly calibrated at all others [@Haider2020].
To mitigate this, one could perform the Hosmer–Lemeshow test (or other applicable tests) multiple times with multiple testing correction at many (or all possible) time points, however this would be less efficient and more difficult to interpret than other measures discussed in this chapter.


```{r echo=FALSE}
learn("sec-car", "reduction")
```


### Houwelingen's $\alpha$

As opposed to evaluating distributions at one or more arbitrary time points, one could instead evaluate distribution predictions at meaningful times.
van Houwelingen proposed several measures [@VanHouwelingen2000] for calibration but only one generalises to all probabilistic survival models, termed here 'Houwelingen's $\alpha$'.
The statistic measures calibration by assessing if the model correctly predicts the true number of total events in the test data.

$$
\frac{\sum_i H_i(T)}{\sum_i \hatH_i(T)}
$$

This follows by noting the closely related nature of survival analysis and counting processes, and exploiting the fact that the sum of the cumulative hazard function is an estimate for the number of events in a given time-period [@dataapplied].
As this result is often surprising result to readers, below is a short experiment using R that demonstrates how the sum of the cumulative hazard estimated by a Kaplan-Meier estimator is identical to the number of randomly simulated deaths in a dataset:

```{r}
#| collapse: true
#| results: 'markup'
#| comment: '#>'
set.seed(42)
library(survival)

event = rbinom(100, 1, 0.7)
times = runif(100)
H = survfit(Surv(times, event) ~ 1)$cumhaz
sum(event) / sum(H)
```


Houwelingen's $\alpha$ is therefore defined by substituting $\sum_i H_i(T)$ for $\sum_i \Delta_i$:

$$
H_\alpha(\Delta, \hatH, T) = \frac{\sum_i \Delta}{\sum_i \hatH(T_i)}
$$

with standard error $SE(H_\alpha) = \exp(1/\sqrt{(\sum_i \Delta)})$.
A model is well-calibrated with respect to $H_\alpha$ if $H_\alpha = 1$.

The next metrics we look at evaluate models across a spectrum of points to assess calibration over time.

## Probabilistic Calibration {#sec-eval-distr-calib-prob}

Calibration over a range of time points may be assessed quantitatively or qualitatively, with graphical methods often favoured.
Graphical methods compare the average predicted distribution to the expected distribution, which can be estimated with the Kaplan-Meier curve, discussed next.

### Kaplan-Meier Comparison

The simplest graphical comparison compares the average predicted survival curve to the Kaplan-Meier curve estimated on the testing data.
Let $\hatS_1,...,\hatS_m$ be predicted survival functions, then the average predicted survival function is the mixture: $\bar{\hatS} = \mean[m]{\hatS_i(\tau)}$.
This estimate can be plotted next to the Kaplan-Meier estimate of the survival distribution in a test dataset (i.e., the true data for model evaluation), allowing for visual comparison of how closely these curves align.
An example is given in @fig-eval-calib, a Cox model (CPH), random survival forest, and relative risk tree with distribution composition, are all compared to the Kaplan-Meier estimator.
This figure highlights the advantages and disadvantages of this method.
The relative risk tree is clearly poorly calibrated as it increasingly diverges from the Kaplan-Meier.
In contrast, the Cox model and random forest cannot be directly compared to one another, as both models frequently overlap with each other and the Kaplan-Meier estimator.
Hence it is possible to say that the Cox and forests models are better calibrated than the risk tree, however it is not possible to say which of those two is better calibrated and whether their distance from the Kaplan-Meier is significant or not at a given time (when not clearly overlapping).


```{r, message=FALSE,warning=FALSE,echo=FALSE}
#| label: fig-eval-calib
#| fig-cap: Comparing the calibration of a Cox PH (CPH), random forest (RF), and relative risk tree (RRT) to the Kaplan-Meier estimate of the survival function calculated on a test set. The calibration of RRT notably decreases over time whereas RF and CPH are closer to the Kaplan-Meier curve.
#| fig-alt: "x-axis is labelled 'T' and ranges from 20 to 100. y-axis is labelled 'S(T)' and rages from 0.8 to 1. Four lines are plotted: CPH (red), KM (green), RF (blue), RRT (purple). The RRT line is quite flat across y=1. The other lines overlap multiple times from (20, 1) to (100, 0.8)."
library(mlr3proba)
library(mlr3pipelines)
library(mlr3extralearners)
library(ggplot2)
library(dplyr)
set.seed(20231211)
t = tgen("simsurv")$generate(400)
s = partition(t)

prrt = as_learner(ppl("distrcompositor", lrn("surv.rpart")))$
  train(t, s$train)$predict(t, s$test)
pcox = lrn("surv.coxph")$train(t, s$train)$predict(t, s$test)
pran = lrn("surv.ranger")$train(t, s$train)$predict(t, s$test)

drrt = autoplot(prrt, "calib", t, s$test)$data
drrt = drrt %>% filter(Group == "Pred") %>% mutate(Group = "RRT")
dcox = autoplot(pcox, "calib", t, s$test)$data
dcox = dcox %>% mutate(Group = if_else(Group == "KM", "KM", "CPH"))
dran = autoplot(pran, "calib", t, s$test)$data
dran = dran %>% filter(Group == "Pred") %>% mutate(Group = "RF")

ggplot(rbind(dcox, dran, drrt), aes(x = x, y = y, color = Group)) +
  geom_line() + theme_bw() + ylim(0, 1) +
  labs(x = "T", y = "S(T)", color = "Model")
```


This method is useful for making broad statements such as "model X is clearly better calibrated than model Y" or "model X appears to make average predictions close to the Kaplan-Meier estimate", but that is the limit in terms of useful conclusions.
One could refine this method for more fine-grained information by instead using relative risk predictions to create 'risk groups' that can be plotted against a stratified Kaplan-Meier, however this method is harder to interpret and adds even more subjectivity around how many risk groups to create and how to create them [@Royston2013].
The next measure we consider includes a graphical method as well as a quantitative interpretation.

### D-Calibration

D-Calibration [@Andres2018; @Haider2020] evaluates a model's calibration by assessing if the predicted survival distributions follow the Uniform distribution as expected, which is motivated by the result that for any random variable $X$ it follows $S_X(x) \sim \calU(0,1)$.
This can be tested using a $\chi^2$ test-statistic:

$$
\chi^2 := \sum_{i=1}^n \frac{(O_i - E_i)^2}{E_i}
$$

where $O_1,...,O_n$ is the observed number of events  in $n$ groups and $E_1,...,E_n$ is the expected number of events.

To utilise this test, the $[0,1]$ codomain of $S_i$ is cut into $B$ disjoint contiguous intervals ('bins') over the full range $[0,1]$.
Let $m$ be the total number of observations, then assuming a discrete uniform distribution as the theoretical distribution, the expected number of events in each bin is $E_i = m/B$ (as the probability of an observation falling into each bin is equal).

The observations in the $i$th bin, $b_i$, are defined by the set:

$$b_i := \{j \in 1,...,m : \lceil \hatS(T_j)B \rceil = i\}$$

where $j = 1,...,m$ are the indices of the observations, $\hatS = (\hatS_1,...,\hatS_m)$ are observed (i.e., predicted) survival functions, $T = (T_1,...,T_m)$ are observed (i.e., the ground truth) outcome times, and $\lceil \cdot \rceil$ is the ceiling function.
The observed number of events in $b_i$ is then the number of observations in that set: $O_i = |b_i|$.

The D-Calibration measure, or $\chi^2$ statistic, is now defined by,

$$
D_{\chi^2}(\hatS, T) :=  \frac{\sum^B_{i = 1} (O_i - \frac{m}{B})^2}{m/B}
$$

This measure has several useful properties.
Firstly, one can test the null hypothesis that a model is 'D-calibrated' by deriving a $p$-value from comparison to $\chi^2_{B-1}$.
Secondly, $D_{\chi^2}$ tends to zero as a model is increasingly well-calibrated, hence the measure can be used for model comparison.
Finally, the theory lends itself to an intuitive graphical calibration method as a D-calibrated model implies:

$$
p = \frac{\sum_i \II(T_i \leq \hatF_i^{-1}(p))}{m}
$$

where $p$ is some value in $[0,1]$, $\hatF_i^{-1}$ is the $i$th predicted inverse cumulative distribution function, and $m$ is again the number of observations.
In words, the number of events occurring at or before each quantile should be equal to the quantile itself, for example 50% of events should occur before their predicted median survival time.
Therefore, one can plot $p$ on the x-axis and the right hand side of the above equation on the y-axis.
A D-calibrated model should result in a straight line on $x = y$.
This is visualised in @fig-eval-dcalib for the same models as in @fig-eval-calib.
This figure supports the previous findings that the relative risk tree is poorly calibrated in contrast to the Cox model and random forest but again no direct comparison between the latter models is possible.


```{r, message=FALSE,warning=FALSE,echo=FALSE}
#| label: fig-eval-dcalib
#| fig-cap: Comparing the D-calibration of a Cox PH (CPH), random forest (RF), and relative risk tree (RRT) to the expected distribution on y=x. As with @fig-eval-calib, the relative risk tree is clearly not D-calibrated (as supported by the figures in the bottom-right). The CPH and RF are closer to the y=x however neither follow it perfectly.
#| fig-alt: "x-axis is labelled 'True (p)' and the y-axis is labelled 'Predicted', both range from 0 to 1. A box in the bottom right says 'DCal (p-values): CPH = 8.2 (0.51); RF = 10 (0.33); RRT = 170 (7e-32). There are four lines on the plot: a blue line (RRT) quickly ascends from (0,0) to (0.1,1) and then is flat; the red (CPH) and green (RF) lines are overlapping and run parallel but not on y=x. Finally a gray dashed line marks the y=x line."
drrt = autoplot(prrt, "dcalib", t, s$test, extend_quantile = TRUE)$data
drrt = drrt %>% mutate(Group = "RRT")
dcox = autoplot(pcox, "dcalib", t, s$test, extend_quantile = TRUE)$data
dcox = dcox %>% mutate(Group = "CPH")
dran = autoplot(pran, "dcalib", t, s$test, extend_quantile = TRUE)$data
dran = dran %>% mutate(Group = "RF")

dcal_coxp = as.numeric(pcox$score(msr("surv.dcalib", truncate = Inf, chisq = TRUE)))
dcal_cox = as.numeric(pcox$score(msr("surv.dcalib", truncate = Inf, chisq = FALSE)))

dcal_ranp = as.numeric(pran$score(msr("surv.dcalib", truncate = Inf, chisq = TRUE)))
dcal_ran = as.numeric(pran$score(msr("surv.dcalib", truncate = Inf, chisq = FALSE)))

dcal_rrtp = as.numeric(prrt$score(msr("surv.dcalib", truncate = Inf, chisq = TRUE)))
dcal_rrt = as.numeric(prrt$score(msr("surv.dcalib", truncate = Inf, chisq = FALSE)))

scores = paste0(sprintf("   %s = %s (%s)", c("CPH", "RF", "RRT"), signif(c(dcal_cox, dcal_ran, dcal_rrt), 2), signif(c(dcal_coxp, dcal_ranp, dcal_rrtp), 2)), collapse = "\n")
scores = paste0("DCal (p-values):\n", scores)

ggplot(rbind(dcox, dran, drrt), aes(x = p, y = q, color = Group)) +
  geom_line() + theme_bw() + ylim(0, 1) + xlim(0, 1) +
  geom_abline(slope = 1, intercept = 0, color = "lightgray", lty = "dashed") +
  labs(x = "True (p)", y = "Predicted", color = "Model") +
  geom_label(aes(x = x, y = y), data.frame(x = 0.75, y = 0.1), label = scores, inherit.aes = FALSE, hjust = "left", size = 2.5)
```


Whilst D-calibration has the same problems as the Kaplan-Meier method with respect to visual comparison, at least in this case there are quantities to help draw more concrete solutions.
For the models in @fig-eval-dcalib, it is clear that the relative risk tree is not D-calibrated with $p<0.01$ indicating the null hypothesis of D-calibration, i.e., the predicted quantiles not following a Discrete Uniform distribution, can be comfortably rejected.
Whilst the D-calibration for the Cox model is smaller than that of the random forest, the difference is unlikely to be significant, as is seen in the overlapping curves in the figure.

The next chapter will look at scoring rules, which provides a more concrete method to analytically compare the predicted distributions from survival models.

